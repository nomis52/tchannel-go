// Autogenerated by thrift-gen. Do not modify.

package stream

import (
	"fmt"
	"io"

	athrift "github.com/apache/thrift/lib/go/thrift"
	"github.com/uber/tchannel-go"
	"github.com/uber/tchannel-go/thrift"
)

// TChanUniqCServer is the interface that must be implemented by a handler.
type TChanUniqCServer interface {
	TChanUniqC

	Run(ctx thrift.Context, call *UniqCRunInCall) error
}

// TChanUniqCClient is the interface used to make remote calls.
type TChanUniqCClient interface {
	TChanUniqC

	Run(ctx thrift.Context) (*UniqCRunOutCall, error)
}

// TChanUniqC2Server is the interface that must be implemented by a handler.
type TChanUniqC2Server interface {
	TChanUniqCServer

	Fakerun(ctx thrift.Context, call *UniqC2FakerunInCall) error
}

// TChanUniqC2Client is the interface used to make remote calls.
type TChanUniqC2Client interface {
	TChanUniqCClient

	Fakerun(ctx thrift.Context) (*UniqC2FakerunOutCall, error)
}

type tchanUniqCStreamingServer struct {
	handler TChanUniqCServer

	// TODO(prashant): Remove this.
	client thrift.TChanStreamingClient
}

// newSTChanUniqCServer returns a tchanUniqCStreamingServer used for embedding in extends.
func newSTChanUniqCServer(handler TChanUniqCServer, client thrift.TChanStreamingClient) *tchanUniqCStreamingServer {
	return &tchanUniqCStreamingServer{
		handler,
		client,
	}
}

// NewSTChanUniqCServer returns a TChanUniqCServer used to route requests to
// the given handler.
func NewSTChanUniqCServer(handler TChanUniqCServer, client thrift.TChanStreamingClient) thrift.TChanStreamingServer {
	return newSTChanUniqCServer(handler, client)
}

func (s *tchanUniqCStreamingServer) Service() string {
	return "UniqC"
}

func (s *tchanUniqCStreamingServer) Methods() []string {
	return []string{
		"run",
	}
}

func (s *tchanUniqCStreamingServer) Handle(ctx thrift.Context, call *tchannel.InboundCall) error {
	arg3Reader, err := call.Arg3Reader()
	if err != nil {
		return err
	}

	methodName := string(call.Operation())
	switch methodName {
	case "UniqC::run":
		return s.handleRun(ctx, call, arg3Reader)
	default:
		return fmt.Errorf("method %v not found in service %v", methodName, s.Service())
	}
}

func (s *tchanUniqCStreamingServer) handleRun(ctx thrift.Context, tcall *tchannel.InboundCall, arg3Reader io.ReadCloser) error {
	call := &UniqCRunInCall{
		client: s.client,
		call:   tcall,
		ctx:    ctx,
	}

	call.reader = arg3Reader

	err :=
		s.handler.Run(ctx, call)
	if err != nil {
		// TODO: encode any Thrift exceptions here.
		return err
	}

	if err := call.checkWriter(); err != nil {
		return err
	}

	// TODO: we may want to Close the writer if it's not already closed.

	return nil
}

type tchanUniqCStreamingClient struct {
	client thrift.TChanStreamingClient
}

// newSTChanUniqCClient returns a tchanUniqCStreamingClient.
func newSTChanUniqCClient(client thrift.TChanStreamingClient) *tchanUniqCStreamingClient {
	return &tchanUniqCStreamingClient{
		client,
	}
}

// NewSTChanUniqCClient returns a TChanUniqCClient that makes remote calls.
func NewSTChanUniqCClient(client thrift.TChanStreamingClient) TChanUniqCClient {
	return newSTChanUniqCClient(client)
}

func (c *tchanUniqCStreamingClient) Run(ctx thrift.Context) (*UniqCRunOutCall, error) {
	call, writer, err := c.client.StartCall(ctx, "UniqC::run")
	if err != nil {
		return nil, err
	}

	outCall := &UniqCRunOutCall{
		client: c.client,
		call:   call,
	}

	outCall.writer = writer

	return outCall, nil
}

// UniqCRunInCall is the object used to stream arguments and write
// response headers for incoming calls.
type UniqCRunInCall struct {
	client thrift.TChanStreamingClient
	call   *tchannel.InboundCall
	ctx    thrift.Context

	reader io.ReadCloser

	writer tchannel.ArgWriter
}

// Read returns the next argument, if any is available. If there are no more
// arguments left, it will return io.EOF.
func (c *UniqCRunInCall) Read() (*String, error) {
	var req String
	if err := c.client.ReadStreamStruct(c.reader, func(protocol athrift.TProtocol) error {
		return req.Read(protocol)
	}); err != nil {
		return nil, err
	}

	return &req, nil
}

// SetResponseHeaders sets the response headers. This must be called before any
// streaming responses are sent.
func (c *UniqCRunInCall) SetResponseHeaders(headers map[string]string) error {
	if c.writer != nil {
		// arg3 is already being written, headers must be set first
		return fmt.Errorf("cannot set headers after writing streaming responses")
	}

	c.ctx.SetResponseHeaders(headers)
	return nil
}

func (c *UniqCRunInCall) writeResponseHeaders() error {
	if c.writer != nil {
		// arg3 is already being written, headers must be set first
		return fmt.Errorf("cannot set headers after writing streaming responses")
	}

	// arg2 writer should be used to write headers
	arg2Writer, err := c.call.Response().Arg2Writer()
	if err != nil {
		return err
	}

	headers := c.ctx.ResponseHeaders()
	if err := c.client.WriteHeaders(arg2Writer, headers); err != nil {
		return err
	}

	return arg2Writer.Close()
}

// checkWriter creates the arg3 writer if it has not been created.
// Before the arg3 writer is created, response headers are sent.
func (c *UniqCRunInCall) checkWriter() error {
	if c.writer == nil {
		if err := c.writeResponseHeaders(); err != nil {
			return err
		}

		writer, err := c.call.Response().Arg3Writer()
		if err != nil {
			return err
		}
		c.writer = writer
	}
	return nil
}

// Write writes a result to the response stream. The written items may not
// be sent till Flush or Done is called.
func (c *UniqCRunInCall) Write(arg *SCount) error {
	if err := c.checkWriter(); err != nil {
		return err
	}
	return c.client.WriteStreamStruct(c.writer, arg)
}

// Flush flushes headers (if they have not yet been sent) and any written results.
func (c *UniqCRunInCall) Flush() error {
	if err := c.checkWriter(); err != nil {
		return err
	}
	return c.writer.Flush()
}

// Done closes the response stream and should be called after all results have been written.
func (c *UniqCRunInCall) Done() error {
	if err := c.checkWriter(); err != nil {
		return err
	}
	return c.writer.Close()
}

// UniqCRunOutCall is the object used to stream arguments/results and
// read response headers for outgoing calls.
type UniqCRunOutCall struct {
	client          thrift.TChanStreamingClient
	call            *tchannel.OutboundCall
	responseHeaders map[string]string
	reader          io.ReadCloser
	writer          tchannel.ArgWriter
}

// Write writes an argument to the request stream. The written items may not
// be sent till Flush or Done is called.
func (c *UniqCRunOutCall) Write(arg *String) error {
	return c.client.WriteStreamStruct(c.writer, arg)
}

// Flush flushes all written arguments.
func (c *UniqCRunOutCall) Flush() error {
	return c.writer.Flush()
}

// Done closes the request stream and should be called after all arguments have been written.
func (c *UniqCRunOutCall) Done() error {
	if err := c.writer.Close(); err != nil {
		return err
	}

	return nil
}

func (c *UniqCRunOutCall) checkReader() error {
	if c.reader == nil {
		arg2Reader, err := c.call.Response().Arg2Reader()
		if err != nil {
			return err
		}

		c.responseHeaders, err = c.client.ReadHeaders(arg2Reader)
		if err != nil {
			return err
		}
		if err := arg2Reader.Close(); err != nil {
			return err
		}

		reader, err := c.call.Response().Arg3Reader()
		if err != nil {
			return err
		}

		c.reader = reader
	}
	return nil
}

// Read returns the next result, if any is available. If there are no more
// results left, it will return io.EOF.
func (c *UniqCRunOutCall) Read() (*SCount, error) {
	if err := c.checkReader(); err != nil {
		return nil, err
	}
	var res SCount
	if err := c.client.ReadStreamStruct(c.reader, func(protocol athrift.TProtocol) error {
		return res.Read(protocol)
	}); err != nil {
		return nil, err
	}

	return &res, nil
}

// ResponseHeaders returns the response headers sent from the server. This will
// block until server headers have been received.
func (c *UniqCRunOutCall) ResponseHeaders() (map[string]string, error) {
	if err := c.checkReader(); err != nil {
		return nil, err
	}
	return c.responseHeaders, nil
}

type tchanUniqC2StreamingServer struct {
	tchanUniqCStreamingServer

	handler TChanUniqC2Server

	// TODO(prashant): Remove this.
	client thrift.TChanStreamingClient
}

// newSTChanUniqC2Server returns a tchanUniqC2StreamingServer used for embedding in extends.
func newSTChanUniqC2Server(handler TChanUniqC2Server, client thrift.TChanStreamingClient) *tchanUniqC2StreamingServer {
	return &tchanUniqC2StreamingServer{
		*newSTChanUniqCServer(handler, client),
		handler,
		client,
	}
}

// NewSTChanUniqC2Server returns a TChanUniqC2Server used to route requests to
// the given handler.
func NewSTChanUniqC2Server(handler TChanUniqC2Server, client thrift.TChanStreamingClient) thrift.TChanStreamingServer {
	return newSTChanUniqC2Server(handler, client)
}

func (s *tchanUniqC2StreamingServer) Service() string {
	return "UniqC2"
}

func (s *tchanUniqC2StreamingServer) Methods() []string {
	return []string{
		"fakerun",
	}
}

func (s *tchanUniqC2StreamingServer) Handle(ctx thrift.Context, call *tchannel.InboundCall) error {
	arg3Reader, err := call.Arg3Reader()
	if err != nil {
		return err
	}

	methodName := string(call.Operation())
	switch methodName {
	case "UniqC2::fakerun":
		return s.handleFakerun(ctx, call, arg3Reader)
	default:
		return fmt.Errorf("method %v not found in service %v", methodName, s.Service())
	}
}

func (s *tchanUniqC2StreamingServer) handleFakerun(ctx thrift.Context, tcall *tchannel.InboundCall, arg3Reader io.ReadCloser) error {
	call := &UniqC2FakerunInCall{
		client: s.client,
		call:   tcall,
		ctx:    ctx,
	}

	call.reader = arg3Reader

	err :=
		s.handler.Fakerun(ctx, call)
	if err != nil {
		// TODO: encode any Thrift exceptions here.
		return err
	}

	if err := call.checkWriter(); err != nil {
		return err
	}

	// TODO: we may want to Close the writer if it's not already closed.

	return nil
}

type tchanUniqC2StreamingClient struct {
	tchanUniqCStreamingClient

	client thrift.TChanStreamingClient
}

// newSTChanUniqC2Client returns a tchanUniqC2StreamingClient.
func newSTChanUniqC2Client(client thrift.TChanStreamingClient) *tchanUniqC2StreamingClient {
	return &tchanUniqC2StreamingClient{
		*newSTChanUniqCClient(client),
		client,
	}
}

// NewSTChanUniqC2Client returns a TChanUniqC2Client that makes remote calls.
func NewSTChanUniqC2Client(client thrift.TChanStreamingClient) TChanUniqC2Client {
	return newSTChanUniqC2Client(client)
}

func (c *tchanUniqC2StreamingClient) Fakerun(ctx thrift.Context) (*UniqC2FakerunOutCall, error) {
	call, writer, err := c.client.StartCall(ctx, "UniqC2::fakerun")
	if err != nil {
		return nil, err
	}

	outCall := &UniqC2FakerunOutCall{
		client: c.client,
		call:   call,
	}

	outCall.writer = writer

	return outCall, nil
}

// UniqC2FakerunInCall is the object used to stream arguments and write
// response headers for incoming calls.
type UniqC2FakerunInCall struct {
	client thrift.TChanStreamingClient
	call   *tchannel.InboundCall
	ctx    thrift.Context

	reader io.ReadCloser

	writer tchannel.ArgWriter
}

// Read returns the next argument, if any is available. If there are no more
// arguments left, it will return io.EOF.
func (c *UniqC2FakerunInCall) Read() (*String, error) {
	var req String
	if err := c.client.ReadStreamStruct(c.reader, func(protocol athrift.TProtocol) error {
		return req.Read(protocol)
	}); err != nil {
		return nil, err
	}

	return &req, nil
}

// SetResponseHeaders sets the response headers. This must be called before any
// streaming responses are sent.
func (c *UniqC2FakerunInCall) SetResponseHeaders(headers map[string]string) error {
	if c.writer != nil {
		// arg3 is already being written, headers must be set first
		return fmt.Errorf("cannot set headers after writing streaming responses")
	}

	c.ctx.SetResponseHeaders(headers)
	return nil
}

func (c *UniqC2FakerunInCall) writeResponseHeaders() error {
	if c.writer != nil {
		// arg3 is already being written, headers must be set first
		return fmt.Errorf("cannot set headers after writing streaming responses")
	}

	// arg2 writer should be used to write headers
	arg2Writer, err := c.call.Response().Arg2Writer()
	if err != nil {
		return err
	}

	headers := c.ctx.ResponseHeaders()
	if err := c.client.WriteHeaders(arg2Writer, headers); err != nil {
		return err
	}

	return arg2Writer.Close()
}

// checkWriter creates the arg3 writer if it has not been created.
// Before the arg3 writer is created, response headers are sent.
func (c *UniqC2FakerunInCall) checkWriter() error {
	if c.writer == nil {
		if err := c.writeResponseHeaders(); err != nil {
			return err
		}

		writer, err := c.call.Response().Arg3Writer()
		if err != nil {
			return err
		}
		c.writer = writer
	}
	return nil
}

// Write writes a result to the response stream. The written items may not
// be sent till Flush or Done is called.
func (c *UniqC2FakerunInCall) Write(arg *SCount) error {
	if err := c.checkWriter(); err != nil {
		return err
	}
	return c.client.WriteStreamStruct(c.writer, arg)
}

// Flush flushes headers (if they have not yet been sent) and any written results.
func (c *UniqC2FakerunInCall) Flush() error {
	if err := c.checkWriter(); err != nil {
		return err
	}
	return c.writer.Flush()
}

// Done closes the response stream and should be called after all results have been written.
func (c *UniqC2FakerunInCall) Done() error {
	if err := c.checkWriter(); err != nil {
		return err
	}
	return c.writer.Close()
}

// UniqC2FakerunOutCall is the object used to stream arguments/results and
// read response headers for outgoing calls.
type UniqC2FakerunOutCall struct {
	client          thrift.TChanStreamingClient
	call            *tchannel.OutboundCall
	responseHeaders map[string]string
	reader          io.ReadCloser
	writer          tchannel.ArgWriter
}

// Write writes an argument to the request stream. The written items may not
// be sent till Flush or Done is called.
func (c *UniqC2FakerunOutCall) Write(arg *String) error {
	return c.client.WriteStreamStruct(c.writer, arg)
}

// Flush flushes all written arguments.
func (c *UniqC2FakerunOutCall) Flush() error {
	return c.writer.Flush()
}

// Done closes the request stream and should be called after all arguments have been written.
func (c *UniqC2FakerunOutCall) Done() error {
	if err := c.writer.Close(); err != nil {
		return err
	}

	return nil
}

func (c *UniqC2FakerunOutCall) checkReader() error {
	if c.reader == nil {
		arg2Reader, err := c.call.Response().Arg2Reader()
		if err != nil {
			return err
		}

		c.responseHeaders, err = c.client.ReadHeaders(arg2Reader)
		if err != nil {
			return err
		}
		if err := arg2Reader.Close(); err != nil {
			return err
		}

		reader, err := c.call.Response().Arg3Reader()
		if err != nil {
			return err
		}

		c.reader = reader
	}
	return nil
}

// Read returns the next result, if any is available. If there are no more
// results left, it will return io.EOF.
func (c *UniqC2FakerunOutCall) Read() (*SCount, error) {
	if err := c.checkReader(); err != nil {
		return nil, err
	}
	var res SCount
	if err := c.client.ReadStreamStruct(c.reader, func(protocol athrift.TProtocol) error {
		return res.Read(protocol)
	}); err != nil {
		return nil, err
	}

	return &res, nil
}

// ResponseHeaders returns the response headers sent from the server. This will
// block until server headers have been received.
func (c *UniqC2FakerunOutCall) ResponseHeaders() (map[string]string, error) {
	if err := c.checkReader(); err != nil {
		return nil, err
	}
	return c.responseHeaders, nil
}
